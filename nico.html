<html>
<head>
<script src="https://cdnjs.cloudflare.com/ajax/libs/vue/2.1.10/vue.min.js"></script>
</head>
<body>
<style>
.box1 {
	position: absolute;
	width: 50px;
	height: 50px;
	background: red;
}

.box2 {
	position: absolute;
	left: 20px;
	right: 20px;
	width: 60px;
	height: 60px;
	background: blue;

}
.box3 {
	position: absolute;
	left: 20px;
	right: 20px;
	width: 60px;
	height: 60px;
	background: green;

}
.box4 {
	position: absolute;
	left: 20px;
	right: 20px;
	width: 60px;
	height: 60px;
	background: cyan;

}
.box5 {
	position: absolute;
	left: 20px;
	right: 20px;
	width: 60px;
	height: 60px;
	background: orange;

}
.box6 {
	position: absolute;
	left: 20px;
	right: 20px;
	width: 60px;
	height: 60px;
	background: magenta;

}

.animarea {
    position:absolute;
    z-index: -1;
    background: black;
    opacity:0.4;
}

body {
	overflow: hidden;
	font-family: monospace;
}

</style>

<div class="timeliner">
    <button v-on:click='dumpData()'>Dump Data</button>
    <button v-on:click='addBox()'>Add Box</button>
    <button v-on:click='removeBox()'>Remove Box</button>
    <br/>
    <div>Area</div>
    <button v-on:click='area.right+=0.1; setAnimArea();'>W+</button>
    <button v-on:click='area.right-=0.1; setAnimArea();'>W-</button>
    <button v-on:click='area.bottom+=0.1; setAnimArea();'>H+</button>
    <button v-on:click='area.bottom-=0.1; setAnimArea();'>H-</button>
    <button v-on:click='area.left-=0.1; area.right-=0.1; setAnimArea();'>Left</button>
    <button v-on:click='area.left+=0.1; area.right+=0.1; setAnimArea();'>Right</button>
    <button v-on:click='area.top-=0.1; area.bottom-=0.1; setAnimArea();'>Up</button>
    <button v-on:click='area.top+=0.1; area.bottom+=0.1; setAnimArea();'>Down</button>
    <div id="animarea" class="animarea">
    </div>
</div>
<script src="timeliner.js"></script>
<script>
var timeliner = new Vue({
  // app initial state
  data: {
    boxes:[],
    target:{},
    area:{
        top:-1,
        bottom:1,
        left:-1,
        right:1
    }
  },

  mounted() {
    this.timeliner = new Timeliner(this.target);
    this.addBox();
    this.animate();
    this.animArea = document.getElementById("animarea");
    setTimeout( () => {
        this.setAnimArea();
    }, 500);
  },

  // computed properties
  // http://vuejs.org/guide/computed.html
  computed: {
  },

  filters: {
  },

  // methods that implement data logic.
  // note there's no DOM manipulation here at all.
  methods: {
    addBox() {
        let box = document.createElement("div");
        let boxName = "box" + (this.boxes.length + 1);
        box.className = boxName;
        this.$el.appendChild(box);

        let layers = [
            [boxName + '_x', Math.random() * 0.5],
            [boxName + '_y', Math.random() * 0.5], 
            [boxName + '_rot', 0]
        ];
        layers.forEach((x) => {
            const layer = x[0],
                initial = x[1];
                
            this.timeliner.addLayer(layer);
            this.target[layer] = initial;
        });
        this.boxes.push(box);

    },
    removeBox() {
        const boxName = 'box' + this.boxes.length;
        const layers = [boxName + '_x', boxName + '_y', boxName + '_rot'];
        layers.forEach((layer) => {
            delete this.target[layer];
        });
        const box = this.boxes[this.boxes.length-1];
        box.parentNode.removeChild(box);
    },
    convertX(x) {
        return x * 100 + w2;
    },
    convertY(y) {
        return y * 100 + h2;
    },
    convertAngle(x) {
        return x * 50;
    },
    animate() {
	    requestAnimationFrame(this.animate);

	    for (var i = 0; i < this.boxes.length; i++) {
	        const box = this.boxes[i];
	        const boxName = 'box' + (i+1);
	        const x = this.target[boxName + '_x'];
	        const y = this.target[boxName + '_y'];
	        const rotate = this.target[boxName + '_rot'];
	        box.style.transform = 'translateX(' +  this.convertX(x) + 'px) translateY(' + this.convertY(y) + 'px) rotate(' +  this.convertAngle(x) + 'deg)';
	    }


	    //box2.style.transform = 'translateX(' +  (target.box2_x * 100 + w2) + 'px) translateY(' + (target.box2_y * 100 + h2) + 'px) rotate(' + target.box2_rotate * 50 + 'deg)'
    },
    setAnimArea() {
    /*
    area:{
        top:-1,
        bottom:1,
        left:-1,
        right:1
    }
    */

        const left = this.convertX(this.area.left);
        const right = this.convertX(this.area.right);
        const top = this.convertY(this.area.top);
        const bottom = this.convertY(this.area.bottom);

        this.animArea.style.left = left + 'px';
        this.animArea.style.right = right + 'px';
        this.animArea.style.top = top + 'px';
        this.animArea.style.bottom = bottom + 'px';
        this.animArea.style.width = (right - left) + 'px';
        this.animArea.style.height = (bottom - top) + 'px';
        console.log('SETTTTTTT', left, right, top, bottom);
        
    },

    dumpData() {
        const timelinerData = window._timeliner_data.getJSONString();
        const data = {
            area:this.area,
            timeliner:JSON.parse(timelinerData)
        }
		let json = JSON.stringify(data);
		var ret = prompt('Hit OK to download otherwise Copy and Paste JSON', json);
		if (!ret) return;
		json = JSON.stringify(data, 0, 2);

		let fileName = 'animdump.json';
		this.saveToFile(json, fileName);
    },

    saveToFile(string, filename) {
	    var a = document.createElement("a");
	    document.body.appendChild(a);
	    a.style = "display: none";

	    var blob = new Blob([string], { type: 'octet/stream' }), // application/json
		    url = window.URL.createObjectURL(blob);
	    
	    a.href = url;
	    a.download = filename;

	    fakeClick(a);

	    setTimeout(function() {
		    // cleanup and revoke
		    window.URL.revokeObjectURL(url);
		    document.body.removeChild(a);
	    }, 500);
    },



  },

  // a custom directive to wait for the DOM to be updated
  // before focusing on the input field.
  // http://vuejs.org/guide/custom-directive.html
  directives: {
  },
  components:{
  }

})


timeliner.$mount('.timeliner')


var box2 = document.getElementById("box2");

var target = {
	box1_x: 0,
	box1_y: 0,
	box1_rotate: 0,

	box2_x:0,
	box2_y:0,
	box2_rotate:0,
};

var target2 = {
	x: 20,
	y: 20,
	rotate: 0

}

/*
timeliner.load({
	"version":"1.2.0","modified":"Mon Dec 08 2014 10:41:11 GMT+0800 (SGT)","title":"Untitled",
	"layers":[
		{
			"name":"box1_x",
			"values":[
				{"time":0.1,"value":0,"_color":"#893c0f","tween":"quadEaseIn"},
				{"time":3,"value":3.500023,"_color":"#b074a0"}
			],"tmpValue":3.500023,"_color":"#6ee167"},
		{
			"name":"box1_y",
			"values":[
				{"time":0.1,"value":0,"_color":"#abac31","tween":"quadEaseOut"},
				{"time":0.5,"value":-1.000001,"_color":"#355ce8","tween":"quadEaseIn"},
				{"time":1.1,"value":0,"_color":"#47e90","tween":"quadEaseOut"},
				{"time":1.7,"value":-0.5,"_color":"#f76bca","tween":"quadEaseOut"},
				{"time":2.3,"value":0,"_color":"#d59cfd"}
			],"tmpValue":-0.5,"_color":"#8bd589"},
		{
			"name":"box1_rotate",
			"values":[
				{"time":0.1,"value":-25.700014000000003,"_color":"#f50ae9","tween":"quadEaseInOut"},
				{"time":2.8,"value":0,"_color":"#2e3712"}
			],"tmpValue":-25.700014000000003,"_color":"#2d9f57"
		},
		{
			"name":"box2_x",
			"values":[
			]
		},
		{
			"name":"box2_y",
			"values":[
			]
		},
		{
			"name":"box2_rotate",
			"values":[
			]
		}

]});
*/

var w2 = window.innerWidth / 2;
var h2 = window.innerHeight / 2;

function animate() {
/*
	requestAnimationFrame(animate);

	box.style.transform = 'translateX(' +  (target.box1_x * 100 + w2) + 'px) translateY(' + (target.box1_y * 100 + h2) + 'px) rotate(' + target.box1_rotate * 50 + 'deg)';

	box2.style.transform = 'translateX(' +  (target.box2_x * 100 + w2) + 'px) translateY(' + (target.box2_y * 100 + h2) + 'px) rotate(' + target.box2_rotate * 50 + 'deg)'
	*/
}

animate();

</script>
</body>
</html>
